<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Webcam Rhythm Game</title>
    <!-- MediaPipe 라이브러리 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at center, #2a2a2a, #000);
            color: white;
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            justify-content: center;
        }

        h2 {
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            margin-bottom: 20px;
            margin-top: 0 !important;
        }

        .container {
            position: relative;
            width: 640px;
            height: 480px;
            border: 2px solid #555;
            border-radius: 16px;
            overflow: hidden;
            background: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
        }

        #input_video {
            display: none;
        }

        #output_canvas {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        /* UI 패널 공통 스타일 */
        .hud-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
            z-index: 10;
        }

        #ui-layer {
            top: 15px;
            left: 15px;
            width: 140px;
            padding: 10px;
        }

        #stats-layer {
            top: 15px;
            right: 15px;
            text-align: right;
            min-width: 120px;
            padding: 10px;
        }

        .info-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: #888;
            margin-bottom: 2px;
            margin-top: 8px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .info-label:first-child {
            margin-top: 0;
        }

        .info-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 4px;
            color: #fff;
        }

        .score-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 900;
            background: linear-gradient(180deg, #fff, #00ff00);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 5px rgba(0, 255, 0, 0.5));
        }

        #combo {
            transition: transform 0.1s;
        }

        .pop-anim {
            animation: pop 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* 랭크 스타일 */
        /* 랭크 스타일 */
        #rank {
            font-size: 32px;
            color: #ffaa00;
            text-shadow: 0 0 15px rgba(255, 170, 0, 0.6);
        }

        /* 피버 게이지 */
        #fever-container {
            width: 100%;
            height: 8px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.8);
        }

        #fever-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff8800, #ffff00);
            box-shadow: 0 0 10px #ff8800;
            transition: width 0.1s linear;
        }

        /* 피버 모드 */
        .fever-active-mode #fever-bar {
            background: linear-gradient(90deg, #00ffff, #0088ff);
            box-shadow: 0 0 15px #00ffff;
        }

        .fever-active-text {
            color: #00ffff !important;
            text-shadow: 0 0 10px #00ffff;
        }

        /* 통계 텍스트 */
        .stat-item {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
        }

        .stat-value {
            font-weight: bold;
            margin-left: 10px;
        }

        .stat-perfect {
            color: #00ffff;
        }

        .stat-great {
            color: #00ff00;
        }

        .stat-good {
            color: #ffff00;
        }

        .stat-bad {
            color: #ff0000;
        }

        /* 중앙 판정 텍스트 */
        .judgement-text {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%) scaleX(-1);
            font-family: 'Orbitron', sans-serif;
            font-size: 72px;
            font-weight: 900;
            font-style: italic;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            display: none;
            z-index: 20;
            -webkit-text-stroke: 2px rgba(0, 0, 0, 0.5);
        }

        #text-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        @keyframes pop {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.4);
            }

            100% {
                transform: scale(1);
            }
        }
    </style>
</head>

<body>

    <h2 style="margin-top: 10px;">Gesture Rhythm Game</h2>

    <div class="container">
        <video id="input_video"></video>
        <canvas id="output_canvas" width="640" height="480"></canvas>

        <div id="text-container">
            <!-- 좌측 정보 (타이머, 콤보, 점수, 랭크, 피버) -->
            <div id="ui-layer" class="hud-panel">
                <div class="info-label">NEXT TARGET</div>
                <div class="info-value" id="target-timer">Waiting...</div>

                <div class="info-label">COMBO</div>
                <div class="info-value" id="combo" style="color: yellow;">0</div>

                <div class="info-label">SCORE</div>
                <div class="score-value" id="score">0</div>

                <div class="info-label">RANK</div>
                <div class="info-value" id="rank">-</div>

                <div class="info-label" id="fever-label">FEVER GAUGE</div>
                <div id="fever-container">
                    <div id="fever-bar"></div>
                </div>
            </div>

            <!-- 우측 정보 (판정 통계) -->
            <div id="stats-layer" class="hud-panel">
                <div class="info-label" style="text-align: right; margin-bottom: 10px;">STATISTICS</div>
                <div class="stat-item stat-perfect">PERFECT <span id="cnt-perfect" class="stat-value">0</span></div>
                <div class="stat-item stat-great">GREAT <span id="cnt-great" class="stat-value">0</span></div>
                <div class="stat-item stat-good">GOOD <span id="cnt-good" class="stat-value">0</span></div>
                <div class="stat-item stat-bad">BAD <span id="cnt-bad" class="stat-value">0</span></div>
            </div>

            <!-- 중앙 판정 이펙트 -->
            <div id="judgement-display" class="judgement-text">PERFECT</div>
        </div>
    </div>

    <script>
        // ---------------------------------------------------------
        // 1. 초기 설정
        // ---------------------------------------------------------
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');

        // WebSocket 연결
        const socket = new WebSocket('ws://' + window.location.host + '/ws/stream/');

        // 게임 상태 변수
        let targetStart = 0;
        let targetEnd = 0;

        let isHandInside = false;
        let entryTime = 0;
        let exitTime = 0;
        let minDistanceInGesture = 9999;

        // 타겟 위치 및 크기 (랜덤 변경됨)
        let targetX = 320;
        let targetY = 240;
        const TARGET_RADIUS = 60;
        const APPROACH_TIME = 2000; // 어프로치 서클이 보이는 시간 (ms)

        // 판정 통계 저장용
        let stats = {
            PERFECT: 0,
            GREAT: 0,
            GOOD: 0,
            BAD: 0
        };

        // ---------------------------------------------------------
        // 2. WebSocket 이벤트 핸들링
        // ---------------------------------------------------------
        socket.onmessage = function (e) {
            const data = JSON.parse(e.data);

            // 다음 목표 수신
            if (data.type === 'system' || data.type === 'next_target') {
                targetStart = data.target_start;
                targetEnd = data.target_end;
                setRandomPosition(); // 위치 랜덤 변경
            }

            // 결과 수신
            if (data.type === 'result') {
                showResult(data.data);
            }
        };

        // 타겟 위치 랜덤 설정 함수
        function setRandomPosition() {
            const padding = TARGET_RADIUS + 30;
            const maxX = 640 - padding;
            const maxY = 480 - padding;
            const minX = padding;
            const minY = padding;

            targetX = Math.random() * (maxX - minX) + minX;
            targetY = Math.random() * (maxY - minY) + minY;
        }

        // 결과 표시 및 애니메이션 함수
        function showResult(res) {
            // 점수 및 랭크 갱신
            document.getElementById('score').innerText = res.total_score;
            document.getElementById('rank').innerText = res.rank;

            // 콤보 업데이트 & 팝업 애니메이션
            const comboEl = document.getElementById('combo');
            comboEl.innerText = res.combo;

            comboEl.classList.remove('pop-anim');
            void comboEl.offsetWidth;

            if (res.combo > 0) {
                comboEl.style.color = 'yellow';
                comboEl.classList.add('pop-anim');
            } else {
                comboEl.style.color = '#aaa';
            }

            // [NEW] 피버 게이지 업데이트
            const feverBar = document.getElementById('fever-bar');
            const feverContainer = document.getElementById('fever-container');
            const feverLabel = document.getElementById('fever-label');

            let widthPct = 0;

            if (res.fever_active) {
                // 피버 발동 중일 때: 남은 시간에 비례해서 게이지가 줄어듦
                // (fever_active_notes / fever_duration) * 100
                widthPct = (res.fever_active_notes / res.fever_duration) * 100;

                // 스타일 적용 (파란색 네온)
                feverContainer.classList.add('fever-active-mode');
                feverLabel.classList.add('fever-active-text');
                feverLabel.innerText = "FEVER TIME!";
            } else {
                // 일반 모드: 게이지 충전량
                // (fever_gauge / fever_max) * 100
                widthPct = (res.fever_gauge / res.fever_max) * 100;

                // 스타일 해제 (노란색/주황색)
                feverContainer.classList.remove('fever-active-mode');
                feverLabel.classList.remove('fever-active-text');
                feverLabel.innerText = "FEVER";
            }

            feverBar.style.width = widthPct + "%";


            // 통계 카운트 증가
            if (stats.hasOwnProperty(res.judgement)) {
                stats[res.judgement]++;
                document.getElementById(`cnt-${res.judgement.toLowerCase()}`).innerText = stats[res.judgement];
            }

            // 중앙 판정 텍스트 표시
            const jDiv = document.getElementById('judgement-display');
            jDiv.innerText = res.judgement;

            let color = '#fff';
            if (res.judgement === 'PERFECT') color = '#00ffff';
            else if (res.judgement === 'GREAT') color = '#00ff00';
            else if (res.judgement === 'GOOD') color = '#ffff00';
            else if (res.judgement === 'BAD') color = '#ff0000';

            jDiv.style.color = color;
            jDiv.style.textShadow = `0 0 20px ${color}`;
            jDiv.style.display = 'block';

            // 텍스트 등장 애니메이션
            // 텍스트 등장 애니메이션
            jDiv.style.transition = 'none';
            jDiv.style.transform = 'translate(-50%, -50%) scale(0.5)';
            jDiv.style.opacity = '1';

            requestAnimationFrame(() => {
                // 1 프레임 뒤에 트랜지션 적용
                requestAnimationFrame(() => {
                    jDiv.style.transition = 'transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.5s';
                    jDiv.style.transform = 'translate(-50%, -50%) scale(1.2)';

                    // 파티클 생성
                    createParticleEffect(targetX, targetY, res.judgement, res.fever_active);

                    // 사라지기
                    setTimeout(() => {
                        jDiv.style.opacity = '0';
                        setTimeout(() => { jDiv.style.display = 'none'; }, 500);
                    }, 500);
                });
            });
        }

        // 파티클 시스템 상수 (복구)
        const COLOR_CYAN = { r: 0, g: 255, b: 255 };
        const COLOR_GREEN = { r: 0, g: 255, b: 0 };
        const COLOR_YELLOW = { r: 255, g: 255, b: 0 };
        const COLOR_RED = { r: 255, g: 0, b: 0 };
        const COLOR_PURPLE = { r: 200, g: 0, b: 255 };
        const COLOR_WHITE = { r: 255, g: 255, b: 255 };
        const COLOR_GOLD = { r: 255, g: 220, b: 100 };

        // 파티클 배열
        let impactParticles = [];
        let trailParticles = [];
        let shockwaves = [];

        // 화면 흔들림 강도
        let screenShake = 0;

        // ImpactParticle 클래스 (타격 순간 짧고 강하게 터지는 스파크)
        class ImpactParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 3.5 + 2.0; // 크기 다양화
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 15 + 8; // 속도감 증가
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.gravity = 0.5; // 중력 추가
                this.alpha = 255;
                this.decay = Math.random() * 8 + 10;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity; // 중력 적용
                this.vx *= 0.92; // 공기 저항 (감속)
                this.vy *= 0.92;
                this.alpha -= this.decay;
            }

            draw(ctx) {
                if (this.alpha <= 0) return;

                ctx.save();
                ctx.globalCompositeOperation = 'lighter';

                // 반짝임 효과 (랜덤하게 밝기 변화)
                const flicker = Math.random() > 0.8 ? 0.5 : 1.0;

                ctx.globalAlpha = (this.alpha / 255) * flicker;

                // 그라데이션 대신 단순 원으로 성능 최적화 + 스타일 변경
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 1)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // 중앙 하이라이트 (흰색)
                ctx.fillStyle = `rgba(255, 255, 255, 0.8)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // TrailParticle 클래스 (꼬리가 남는 입자)
        class TrailParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 7 + 5;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.history = [];
                this.alpha = 255;
                this.decay = Math.random() * 3 + 3;
            }

            update() {
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > 4) this.history.shift();
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.92;
                this.vy *= 0.92;
                this.alpha -= this.decay;
            }

            draw(ctx) {
                if (this.alpha <= 0) return;

                ctx.save();
                ctx.globalCompositeOperation = 'lighter';

                if (this.history.length > 1) {
                    for (let i = 0; i < this.history.length - 1; i++) {
                        const alpha = (this.alpha * (i / this.history.length) * 0.5) / 255;
                        ctx.strokeStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(this.history[i].x, this.history[i].y);
                        ctx.lineTo(this.history[i + 1].x, this.history[i + 1].y);
                        ctx.stroke();
                    }
                }

                ctx.globalAlpha = this.alpha / 255;
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.alpha / 255})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4.0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Shockwave 클래스 (충격파 링)
        class Shockwave {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 60;
                this.alpha = 200;
                this.width = 10;
            }

            update() {
                this.radius += 10;
                this.alpha -= 12;
                this.width = Math.max(0.5, this.width * 0.9);
            }

            draw(ctx) {
                if (this.alpha <= 0 || this.width < 0.5) return;

                ctx.save();
                ctx.globalAlpha = this.alpha / 255;
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.alpha / 255})`;
                ctx.lineWidth = this.width;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        // 파티클 생성 함수 (더 풍부한 비주얼 효과)
        function createParticleEffect(x, y, judgement, isFever = false) {
            let color;
            let particleCount;
            let speedMult = 1.0;

            if (judgement === 'PERFECT') {
                color = COLOR_CYAN;
                particleCount = 50;
                screenShake = 15; // 강력한 화면 흔들림
                speedMult = 1.2;
            } else if (judgement === 'GREAT') {
                color = COLOR_GREEN;
                particleCount = 30;
                screenShake = 6;
                speedMult = 1.0;
            } else if (judgement === 'GOOD') {
                color = COLOR_YELLOW;
                particleCount = 15;
                screenShake = 2;
                speedMult = 0.8;
            } else if (judgement === 'BAD') {
                color = COLOR_RED;
                particleCount = 8;
                screenShake = 0;
                speedMult = 0.5;
            } else {
                return;
            }

            // 피버 모드일 때 추가 부스팅
            if (isFever) {
                particleCount += 20;
                screenShake += 5;
            }

            // Impact 파티클 생성
            for (let i = 0; i < particleCount; i++) {
                // 피버이거나 PERFECT일 때 가끔 금색/흰색 파티클 섞기
                let pColor = color;
                if ((isFever || judgement === 'PERFECT') && Math.random() < 0.3) {
                    pColor = (Math.random() < 0.5) ? COLOR_GOLD : COLOR_WHITE;
                }

                const p = new ImpactParticle(x, y, pColor);
                p.vx *= speedMult;
                p.vy *= speedMult;
                impactParticles.push(p);
            }

            // Trail 파티클 생성 (PERFECT/GREAT 일 때만 많이)
            if (judgement === 'PERFECT' || judgement === 'GREAT' || isFever) {
                const trailCount = Math.floor(particleCount * 0.5);
                for (let i = 0; i < trailCount; i++) {
                    trailParticles.push(new TrailParticle(x, y, color));
                }
            }

            // 충격파 생성 (PERFECT는 2개)
            shockwaves.push(new Shockwave(x, y));
            if (judgement === 'PERFECT') {
                setTimeout(() => shockwaves.push(new Shockwave(x, y)), 100);
            }
        }

        // 파티클 업데이트 및 렌더링
        function updateAndDrawParticles(ctx) {
            // 충격파 업데이트 및 그리기
            for (let i = shockwaves.length - 1; i >= 0; i--) {
                shockwaves[i].update();
                if (shockwaves[i].alpha <= 0) {
                    shockwaves.splice(i, 1);
                } else {
                    shockwaves[i].draw(ctx);
                }
            }

            // Trail 파티클 업데이트 및 그리기
            for (let i = trailParticles.length - 1; i >= 0; i--) {
                trailParticles[i].update();
                if (trailParticles[i].alpha <= 0) {
                    trailParticles.splice(i, 1);
                } else {
                    trailParticles[i].draw(ctx);
                }
            }

            // Impact 파티클 업데이트 및 그리기 (가장 위에)
            for (let i = impactParticles.length - 1; i >= 0; i--) {
                impactParticles[i].update();
                if (impactParticles[i].alpha <= 0) {
                    impactParticles.splice(i, 1);
                } else {
                    impactParticles[i].draw(ctx);
                }
            }
        }

        // ---------------------------------------------------------
        // 3. MediaPipe & Rendering 루프
        // ---------------------------------------------------------
        function onResults(results) {
            // 캔버스 초기화
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // [NEW] 화면 흔들림 효과 적용
            if (screenShake > 0.5) {
                const dx = (Math.random() - 0.5) * screenShake;
                const dy = (Math.random() - 0.5) * screenShake;
                canvasCtx.translate(dx, dy);
                screenShake *= 0.9; // 흔들림 감쇠
            } else {
                screenShake = 0;
            }

            // 비디오 그리기
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            const currentTime = Date.now();
            const timeToHit = targetStart - currentTime;

            // --- [1] 타겟 원 그리기 (Neon Line Style) ---
            canvasCtx.save();
            canvasCtx.beginPath();
            canvasCtx.arc(targetX, targetY, TARGET_RADIUS, 0, 2 * Math.PI);

            if (isHandInside) {
                // 손이 들어왔을 때: Green Glow + Thick Line
                canvasCtx.shadowBlur = 20;
                canvasCtx.shadowColor = '#00ff00';
                canvasCtx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                canvasCtx.strokeStyle = '#00ff00';
                canvasCtx.lineWidth = 5;
            } else {
                // 기본 상태: Cyan Neon + Sharp Line
                canvasCtx.shadowBlur = 15;
                canvasCtx.shadowColor = '#00ffff';
                canvasCtx.fillStyle = 'rgba(0, 20, 40, 0.3)'; // 약간 어두운 반투명 배경
                canvasCtx.strokeStyle = '#00ffff';
                canvasCtx.lineWidth = 3;
            }

            canvasCtx.fill();
            canvasCtx.stroke();

            // 내부 디테일 라인 (선명한 흰색 실선)
            canvasCtx.shadowBlur = 0;
            canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            canvasCtx.lineWidth = 1;
            canvasCtx.stroke();

            canvasCtx.restore();

            // --- [2] 어프로치 서클 그리기 (타이밍 시각화) ---
            if (timeToHit > 0 && timeToHit <= APPROACH_TIME) {
                const progress = 1 - (timeToHit / APPROACH_TIME);
                const startScale = 2.5; // 시작 크기 배율
                const currentRadius = TARGET_RADIUS * (1 + (startScale - 1) * (1 - progress));

                canvasCtx.beginPath();
                canvasCtx.arc(targetX, targetY, currentRadius, 0, 2 * Math.PI);
                canvasCtx.lineWidth = 3;
                canvasCtx.strokeStyle = `rgba(0, 255, 255, ${0.5 + progress * 0.5})`; // 투명도 조절
                canvasCtx.stroke();
            }

            // --- [3] 타이머 텍스트 갱신 ---
            if (timeToHit > 0) {
                document.getElementById('target-timer').innerText = (timeToHit / 1000).toFixed(2) + "s";
            } else if (timeToHit > -1000) {
                document.getElementById('target-timer').innerText = "NOW!";
            } else {
                document.getElementById('target-timer').innerText = "Waiting...";
            }

            // --- [4] 손 인식 및 충돌 처리 ---
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const indexFinger = landmarks[8]; // 검지 손가락 끝

                // 좌표 변환 (0~1 -> 픽셀)
                const fingerX = indexFinger.x * canvasElement.width;
                const fingerY = indexFinger.y * canvasElement.height;

                // 거리 계산
                const distance = Math.sqrt(Math.pow(fingerX - targetX, 2) + Math.pow(fingerY - targetY, 2));

                // 손 위치 커서
                canvasCtx.beginPath();
                canvasCtx.arc(fingerX, fingerY, 8, 0, 2 * Math.PI);
                canvasCtx.fillStyle = '#ff0055';
                canvasCtx.fill();
                canvasCtx.strokeStyle = 'white';
                canvasCtx.lineWidth = 2;
                canvasCtx.stroke();

                const currentlyInside = distance <= TARGET_RADIUS;

                if (currentlyInside) {
                    minDistanceInGesture = Math.min(minDistanceInGesture, distance);
                    if (!isHandInside) {
                        isHandInside = true;
                        entryTime = Date.now();
                        // 진입 시 효과음이나 시각 효과를 여기에 추가 가능
                    }
                } else {
                    if (isHandInside) {
                        // 손이 나가는 순간 -> 데이터 전송
                        isHandInside = false;
                        exitTime = Date.now();

                        socket.send(JSON.stringify({
                            'action': 'gesture_complete',
                            'entry_time': entryTime,
                            'exit_time': exitTime,
                            'min_dist': minDistanceInGesture
                        }));
                        minDistanceInGesture = 9999;
                    }
                }
            }
            // --- [5] 파티클 이펙트 렌더링 ---
            updateAndDrawParticles(canvasCtx);
            canvasCtx.restore();
        }

        // MediaPipe 초기화
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        camera.start();

    </script>
</body>

</html>